.. _IOBridge:

IOBridge
========

The ``IOBridge`` is the central and lowest-level component of *spray-io*. It provides a thin and efficient
"adapter layer" between the network (i.e. sockets) and Akka actors.

There are two sides to this "adapter layer":

Outgoing network "commands"
  Command messages coming in from the application, like "connect to a certain address", "write this series of bytes" or
  "close the connection" are applied to the respective connection/socket.

Incoming network "events"
  Everything that happens on a socket managed by an ``IOBridge``, like the acceptance of a new connection, the reading
  of a series of bytes or the closing of the connection, is packaged in a respective event message and sent to
  a "handler" actor responsible for the connection.

One ``IOBridge`` instance occupies exactly one private thread, from which it manages one Java NIO selector. Even though
you can create as many IOBridges as you like, every single one can easily handle many thousand connections. Therefore
most applications will only need to create a single ``IOBridge`` for all their incoming and outgoing (i.e. server-
and client-side) connections.

Even though it provides a similar API an ``IOBridge`` is *not* an actor itself. (Akka Actors cannot occupy their
own thread. Rather the scheduling of their execution slots is managed by an independently configurable dispatcher.)


Lifecycle
---------

In most cases you'll want to create and shutdown an ``IOBridge`` like this:

.. includecode:: code/docs/IOBridgeExamplesSpec.scala
   :snippet: example-1

Even though the construction of an ``IOBridge`` is easiest as shown in this example (with a single ``ActorSystem``
argument) the system passed to the constructor is only used for logging purposes. The ``IOBridge`` instance itself
exists independently of any ``ActorSystem`` and could therefore be used by actors from several systems at the same
time.


Interface
---------

The public interface of an ``IOBridge`` is very simple. It looks like this::

    def thread: Option[Thread]
    def start(): this.type
    def stop()
    def ! (cmd: Command)(implicit sender: ActorRef = Actor.noSender)
    def tell(cmd: Command, sender: ActorRef)

Apart from starting, stopping and querying for its ``Thread`` all commmunication with an ``IOBridge`` happens
asynchronously through ``Command`` and ``Event`` messages.


Commands
--------

Once you have an ``IOBridge`` instance you'll want to send commands to it.
These are all the defined commands:

.. includecode:: /../spray-io/src/main/scala/spray/io/IOBridge.scala
   :snippet: public-commands

And here is what action they instruct the bridge to perform:

Bind
  Start listening for incoming connections on a particular port. The sender receives a ``Bound`` event upon completion.

Unbind
  Revert a previous ``Bind``. The sender receives an ``Unbound`` event upon completion.

Connect
  Connect to remote address. The sender received a ``Connected`` event upon completion.

GetStats
  Send the sender an ``IOBridge.Stats`` message containing simple bridge statistics.

Register
  Register the given ``Handle``, that was newly created as a result of a ``Connected`` event, and start accepting
  read events on its connection.

Close
  Close the connection of the given ``Handle``. If there are pending ``Send`` commands that haven't yet been completed
  the closing is queued. Special case: If the ``reason`` is ``ConfirmedClose`` the socket is not closed right away, but
  rather via a full TCP FIN message exchange. I.e. at first a TCP FIN message is sent and the peers "ack'ing" FIN is
  awaited before the socket is closed.
  Independently of when the socket is actually closed the handler of the connection receives a ``Closed`` event after
  it has happened.

Send
  Write the contents of the given ByteBuffers to the handles connection. If ``ack`` is defined the sender receives its
  content as a "send confirmation" message when all bytes have been successfully written to the socket.

StopReading
  Stop reading from the handles connection.

ResumeReading
  Resume reading from the handles connection.


Events
------

These are all the events that are generated by an ``IOBridge`` instance:

.. includecode:: /../spray-io/src/main/scala/spray/io/IOBridge.scala
   :snippet: public-events

And these are their semantics:

Bound
  Sent as a confirmation of a preceding ``Bind`` command.

Unbound
  Sent as a confirmation of a preceding ``Unbind`` command.

Connected
  Sent after a new connection has been established, either as a result of a preceding ``Bind`` or ``Connect`` command.

Closed
  Sent after a connection has been closed.

Received
  Sent after a chunk of data has been read from the connections socket. Will never contain more than the number of
  bytes configured as ``read-buffer-size`` in the ``IOBridgeSettings``.


Handle
------

An ``IOBridge`` identifies connections using a "handle", with can be any object implementing the ``Handle`` interface:

.. includecode:: /../spray-io/src/main/scala/spray/io/Handle.scala
   :snippet: source-quote

The creation of actual handle instances is delegated to the application. This gives the user the freedom to structure
the application logic in a lookup-free way, since all connection-specific event messages always carry the handle
instance that was created by the application.

The typical pattern is that the application creates a new ``Handle`` instance after the reception of a ``Connected``
event, which is the only way to get a hold of the required ``Key`` for the handle. After handle creation the application
then registers it with the ``IOBridge`` via a ``Register`` command.